/**
 * Set ids and resolve references
 * 
 * @copyright  Copyright (C) 2023+, Yepr, Herman Peeren. All rights reserved.
 * @license    GNU General Public License version 3 or later; see LICENSE.txt
 */

    // Per meta-language we have an objectReferencerMap:
    // a map of all objects that can be referenced and the object (referencer), possibly higher in the hierarchy, that has the name and id
    // The referencer can be the same as the referenced object.
    // Those objectReferencerMaps are per language apart in a JS-file, generated by the projectforms-generator.
    // todo: when combining multiple languages, then combine those objectReferencerMaps

    // The objectTypeMap maps objectTypes to objectMaps
    // Only the objectTypes that contain the name and the id in initialiseObjectMap()
    let objectTypeMap = new Map;

    // An objectMap maps the id of an object to its name
    // The objects are those nodes that have the name and id of the object
    // In LIonCore_M3 those nodes are the LanguageEntities.
    // The keys are the ids of objects of some objectType.
    // The keys are mapped to the name of the object

    // Options are all possibilities for a reference to a type todo: this should probably also be integrated in the objectTypeMap
    let options = [];

    // The id of the latest object that was set
    let currentObjectId = null;
    
    // A child is a part of an object
    // like a Feature is a child of a Classifier in LIonCore_M3
    // or a Field is a child of an Entity in ER1

    // childReferences and childOptions are 3-dimensional arrays:
    //     1. first index:  the parent object name
    //     2. second index: the id of the instance of the parent object
    //     3. third index:  the child object
    let childReferences = [];
    let childOptions = [];

    // The id of the latest child object that was set
    let currentChildObjectId = null;
    
    
    // To be removed ------------------
    let entities = [];
    let entityOptions = [];
    let pages = [];
    let pageOptions = [];
    // fields and fieldOptions are 2-dimensional arrays, with first index an entity_id
    let fields = {};
    let fieldOptions = [];
    
    // END of to be removed--------------

    /**
     * Initialise list of instances of an objectType when name of an object of that objectType changes (or object is deleted or added)
     */
    function initialiseObjectMap(objectType) {

        // If there was a objectMap for this objectType, then delete it
        if (objectTypeMap.has(objectType))
        {
            objectTypeMap.delete(objectType);
        }

        let objectNameList = [].slice.call(document.querySelectorAll('.' + lowercaseFirstLetter(objectType) + 'Name'));

        // Make a new, empty objectMap
        let objectMap = new Map;
        let index = 0;

        // get the <object>_id of every instance of the current <object>, creating an uuid if <object>_id doesn't exist
        objectNameList.forEach(instanceName => {
            // for-var ....<object>_name always has a var ....<object>_id
            let object_id = document.getElementById(instanceName.id.replace('name', 'id'));

            // give that object_id an uuid if empty
            if (!object_id.value) {

                object_id.value = uuidv4();
            }

            // Make a new entry in the objectMap, with the <object>_id as key and the object-name and index as value
            objectMap.set(object_id.value, {name:instanceName.value, index: index});

            /*
            // Look for a switch with sub-types // todo: ??? maybe better go up from the subnode then down from the parent...???
            let subTypeElement = document.getElementById(instanceName.id.replace('name', objectType.toLowerCase() + '_type'));
            if (subTypeElement != null)
            {
                let subtype = subTypeElement.value; // todo: do something with it...
            }*/

            index++;

        });

        // Put the objectMap in the objectTypeMap of this objectType
        objectTypeMap.set(objectType, objectMap);


        setRefOptions(objectType);

    }
    /**
     * Set the options of all reference dropdowns for an objectType.
     *
     */
    function setRefOptions(objectType) {
        // get all references to dropdown references for this object
        let Refs = [].slice.call(document.querySelectorAll('.' + objectType + 'Ref'));
        Refs.forEach(Ref => {
    
            // the selected value is also in the hidden reference_id-field, even if the options are not yet restored
            let selected = document.getElementById(Ref.id + '_id');
    
            // Put the options in the select-box
            Ref.innerHTML = options[objectType];
    
            // and restore the value (will only be restored if value is in options)
            Ref.value = selected.value;
        });
    }
    
    /**
     * Set the options of all reference dropdowns for a child. todo: from entities & fields to parent & child
     */
    function setChildRefOptions(childName, parentName) {
        // get all references to fields dropdowns
        let fieldRefs = [].slice.call(document.querySelectorAll('.FieldRef'));
        fieldRefs.forEach(fieldRef => {
    
            // the selected value is also in the hidden reference_id-field, even if the options are not yet restored
            let selected = document.getElementById(fieldRef.id + '_id');
    
            // Get the entity_id of this field-list reference
            let entity_id = document.getElementById(fieldRef.id.replace('__field_reference', '__entity_reference_id')).value;
    
            // Put the options in the select-box
            fieldRef.innerHTML = childOptions[parentName][entity_id];
    
            // and restore the value (will only be restored if value is in options)
            fieldRef.value = selected.value;
        });
    
        // get the <object>_type of every instance of the current <object>. Will be null if <object>_type doesn't exist
        object_types = [];
        objectMap[objectType].forEach(instanceName => {
            // for-var ....<object>_name has a hidden var ....<object>_id
            object_type = document.getElementById(instanceName.id.replace(objectType.toLowerCase() + '_name', objectType.toLowerCase() + '_type'));
    
            let type = "";
            if (object_type != null) {
                type = object_type.value + ": ";
            }
    
            object_types.push(type);
        })
    
    
        // make the options with object_ids as values and object_names visible in the list
        options[objectType] = '<option value="0">&nbsp;</option>';
        for (let i = 0; i < objectMap[objectType].length; i++) {
            options[objectType] += `<option value=${object_ids[i].value}>${object_types[i]
            + objectMap[objectType][i].value}</option>` + '\n';
        }

    }
    
    /**
     * Update list of ALL references to a child object.
     * For instance: list of references to fields (= child object) for all entities (= parent object)
     *
     */
    function updateAllChildReferencesList(childName, parentName) {
    
        // Empty child-objects-list for this parent object
        childReferences[parentName] = [];
    
        // Get all child-object-fields from this form // todo: each child object must be unique within the parent scope, but not beyond!!!
        const allChildren = [].slice.call(document.querySelectorAll('.' + childName.toLowerCase() + 'Name'));
    
        // Put the <child object>_name and <child object>_id of every <child object> in the <child object>-array, per <parent object>_id
        // The entity_id is also added for easy reference when building the options-html
        allChildren.forEach(childField => {
            const parent_id = getParentIdForChild(childField);
            if (!(parent_id in childReferences[parentName])) childReferences[parentName][parent_id] = [];
            childReferences[parentName][parent_id].push({
                fieldName: childField.value,
                fieldId: getChildId(childField),
                parentId: parent_id
            });
        })
    
        // Update fieldS options for all entities
        updateAllChildOptions(childName, parentName);
    }
    
    /**
     * Get the <child>_id of this <child>Name-field.
     * A <child>Name-field has a <child>_name; the corresponding <child>_id has '<child>_id' on that spot.
     *
     */
    function getChildId(childField) {
        // This <child> should have a <child>-id todo: the name of the child instead of "field" (at the moment that name is "field")
        const field_id = document.getElementById(childField.id.replace('field_name', 'field_id'));
    
        // give that <child>_id an uuid if empty
        if (!field_id.value) {
            field_id.value = uuidv4();
        }
    
        return field_id.value;
    }
    
    /**
     * Get the entity_id of the entity this fieldName-field (= property) belongs to.
     * A fieldName-field has a 'property_name'; the corresponding entity_id has 'entity_id' on that spot
     * In the data-definition a field (= a property) belongs to a specific entity
     * todo: maybe a field should be a property OR a reference! For now it is only a property...
     */
    function getParentIdForChild(childField) {
        // This field should have an entity-id for the entity it belongs to todo: replace property and entity with the proper names of the child and parent
        entity_id = document.getElementById(childField.id.replace('field_name', 'entity_id'));
    
        // If still empty, then find the entity_id of the entity it belongs to
        if (!entity_id.value) {
            fieldId = childField.id;
            firstPart = fieldId.substr(0, fieldId.indexOf("_field__field"))
            entity_id.value = document.getElementById(firstPart + "_entity_id").value;
        }
    
        return entity_id.value;
    }
    
    /**
     * Update all child object options for this child object
     * For instance: update all field-options for entities
     */
    function updateAllChildOptions(childName, parentName) {
    
        // Empty fieldsOptions-list
        childOptions[parentName] = [];
    
        // Put the options with <child object>_ids as values and <child object>_names visible in the list in childOptions-list per <parent_object>_id
        for (let parent_id in childReferences[parentName]) {
            let parent = childReferences[parentName][parent_id];
            let parentChildOptions = '<option value="0">&nbsp;</option>';
            for (let i = 0; i < parent.length; i++) {
                parentChildOptions += `<option value=${parent[i].fieldId}>${parent[i].fieldName}</option>` + '\n';
            }
    
            childOptions[parentName][parent_id] = parentChildOptions;
        }
    
        // Put the options in the document
        setChildRefOptions(childName, parentName);
    
    }
    
    /**
     * Update list of references for given parent entity when child entity name changes
     */
    function editChildList(field) {
    
        // Get the field_id for this field
        //const field_id = getfieldId(field);
    
        // Get the entity-id for the entity this field belongs to
        //const entity_id = getEntityIdForfield(field);
    
        // TODO: Update the fields-list and the options in the fields-dropdown for only this entity
    
        // temporary: Update ALL field-lists and options in the fields-dropdowns
        // todo: get the childName and parentName
        const childName = 'Field';
        const parentName = 'Entity';
        updateAllChildReferencesList(childName, parentName);
    
    }
    
    // put the changed ID of a referred to object (from drop down select) in the hidden field
    function backupObjectID(event) {
        // If the list was still empty: fill it...
        if (event.target.value == 999999) {
            const type = event.target.type
            const objectType = type.substring(0, type.search('Reference'));
            initialiseObjectMap(objectType);
            return;
        }
    
        // the hidden field with the reference_id has the same id as the select box that triggered this function + _id
        reference_id = document.getElementById(event.target.id + '_id');
        reference_id.value = event.target.value;
    
        // todo: get the childName and parentName
        const childName = 'Field';
        const parentName = 'Entity';
    
        // After updating a reference to a parent-object, we might set the options for the children (if any)
        // For instance after updating a reference to an entity, we might update a fields-dropdown
        // todo: check if there is a child for this select-box AND only update the fields of that child-dropdown
        updateAllChildOptions(childName, parentName);
    }
    
    // put the changed ID of a referred to field (from drop down select) in the hidden field
    function backupChildID(event) {
        // If the list was still empty: fill it...
        if (event.target.value == 999999) {
            // todo: get the childName and parentName
            const childName = 'Field';
            const parentName = 'Entity';
    
            editChildList(event.target);
            return;
        }
    
        // the hidden field with the field_reference_id has the same id as the select box that triggered this function + _id
        reference_id = document.getElementById(event.target.id + '_id');
        reference_id.value = event.target.value;
    }
    
    // simple uuid-function
    function uuidv4() {
        return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
            (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
        );
    }
    
    window.onload = function () {
        //TODO: server-side initialsation

        // Init objects list
        // We hardcode 2 objects to refer to here: Entity and Page. Entity has a child object field. Todo: get all objects from meta-model
        let objectTypes = [['Entity', ['field']], ['Page']];
    
        // Init object references list
        objectTypes.forEach(objectType => {
            // Put each object as entry in the array of object references and object options
            objectMap[objectType[0]] = [];
            options[objectType[0]] = [];
    
            // And to store possible child object references and the child object options
            childReferences[objectType[0]] = [];
            childOptions[objectType[0]] = [];
    
            // Init all references to this object. For instance: references to entities.
            initialiseObjectMap(objectType[0]);
    
    
            // Add child objects if available
            if (objectType.length > 1) {
                childReferences[objectType[0]] = [];
                objectType[1].forEach(childName => {
                    childReferences[objectType[0]][childName] = [];
    
                    // Init all references to this child object. For instance: references to all fields of entities.
                    updateAllChildReferencesList(childName, objectType[0]);
                });
            }
        });
    
        // TODO: this can then go
        /*editEntitiesList();
        editPagesList();
        editfieldsList();*/
    };

    function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    }

    function lowercaseFirstLetter(string) {
        return string.charAt(0).toLowerCase() + string.slice(1);
    }
    
    // ------------------------Under this line is DEPRECATED and should be removed once the above code works.---------------
    
    /**
     * Set the options of all ENTITY reference dropdowns
     */
    function setEntityRefOptions() {
        // get all references to entities dropdowns
        let entityRefs = [].slice.call(document.querySelectorAll('.entityRef'));
        entityRefs.forEach(entityRef => {
    
            // the selected value is also in the hidden reference_id-field, even if the options are not yet restored
            let selected = document.getElementById(entityRef.id + '_id');
    
            // Put the options in the select-box
            entityRef.innerHTML = entityOptions;
    
            // and restore the value (will only be restored if value is in options)
            entityRef.value = selected.value;
        });
    }
    
    /**
     * Set the options of all field reference dropdowns
     */
    function setfieldRefOptions() {
        // get all references to entities dropdowns
        let fieldRefs = [].slice.call(document.querySelectorAll('.fieldRef'));
        fieldRefs.forEach(fieldRef => {
    
            // the selected value is also in the hidden reference_id-field, even if the options are not yet restored
            let selected = document.getElementById(fieldRef.id + '_id');
    
            // Get the entity_id of this field-list reference
            let entity_id = document.getElementById(fieldRef.id.replace('__field_reference', '__entity_reference_id')).value;
    
            // Put the options in the select-box
            fieldRef.innerHTML = fieldOptions[entity_id];
    
            // and restore the value (will only be restored if value is in options)
            fieldRef.value = selected.value;
        });
    }
    
    /**
     * Set the options of all PAGE reference dropdowns
     */
    function setPageRefOptions() {
        // get all references to pages dropdowns
        let pageRefs = [].slice.call(document.querySelectorAll('.pageRef'));
        pageRefs.forEach(pageRef => {
    
            // the selected value is also in the hidden reference_id-field, even if the options are not yet restored
            let selected = document.getElementById(pageRef.id + '_id');
    
            // Put the options in the select-box
            pageRef.innerHTML = pageOptions;
    
            // and restore the value (will only be restored if value is in options)
            pageRef.value = selected.value;
        });
    }
    
    /**
     * Update ENTITIES list when entity name changes
     */
    function editEntitiesList() {
    
        entities = [].slice.call(document.querySelectorAll('.entityName'));
    
        // get the entity_id of every entity, creating an uuid if entity_id doesn't exist
        entity_ids = [];
        entities.forEach(entityName => {
            // for-var ....entity_name has a hidden var ....entity_id
            entity_id = document.getElementById(entityName.id.replace('entity_name', 'entity_id'));
    
            // give that entity_id an uuid if empty
            if (!entity_id.value) {
                entity_id.value = uuidv4();
            }
    
            entity_ids.push(entity_id);
        })
    
    
        // make the options with entity_ids as values and entity_names visible in the list
        entityOptions = '<option value="0">&nbsp;</option>';
        for (let i = 0; i < entities.length; i++) {
            entityOptions += `<option value=${entity_ids[i].value}>${entities[i].value}</option>` + '\n';
        }
    
        setEntityRefOptions();
    
    }
    
    /**
     * Get the field_id of this fieldName-field
     * A fieldName-field has a 'property_name; the corresponding property_id has 'property_id' on that spot
     * todo: maybe a field should be a property OR a reference! For now it is only a property...
     */
    function getPropertyId(field) {
        // This field should have a property-id
        const property_id = document.getElementById(field.id.replace('property_name', 'property_id'));
    
        // give that field_id an uuid if empty
        if (!property_id.value) {
            property_id.value = uuidv4();
        }
    
        return property_id.value;
    }
    
    /**
     * Get the entity_id of the entity this fieldName-field (= property) belongs to.
     * A fieldName-field has a 'property_name'; the corresponding entity_id has 'entity_id' on that spot
     * In the data-definition a field (= a property) belongs to a specific entity
     * todo: maybe a field should be a property OR a reference! For now it is only a property...
     */
    function getEntityIdForProperty(field) {
        // This field should have an entity-id for the entity it belongs to
        entity_id = document.getElementById(field.id.replace('property_name', 'entity_id'));
    
        // If still empty, then find the entity_id of the entity it belongs to
        if (!entity_id.value) {
            fieldId = field.id;
            firstPart = fieldId.substr(0, fieldId.indexOf("_property__property"))
            entity_id.value = document.getElementById(firstPart + "_entity_id").value;
        }
    
        return entity_id.value;
    }
    
    /**
     * Update fieldS-list for all entities
     *
     */
    function updateAllfields() {
    
        // Empty fields-list
        fields = [];
    
        // Get all fieldname-fields from this form
        const fieldsAll = [].slice.call(document.querySelectorAll('.fieldName'));
    
        // Put the property_name and property_id of every field in the fields-array, per entity_id
        // The entity_id is also added for easy reference when building the options-html
        fieldsAll.forEach(field => {
            const entity_id = getEntityIdForProperty(field);
            if (!(entity_id in fields)) fields[entity_id] = [];
            fields[entity_id].push({fieldName: field.value, fieldId: getPropertyId(field), entityId: entity_id});
        })
    
        // Update fieldS options for all entities
        updateAllfieldsOptions();
    }
    
    /**
     * Update fieldS options for all entities
     */
    function updateAllfieldsOptions() {
    
        // Empty fieldsOptions-list
        fieldsOptions = [];
    
        // Put the options with field_ids as values and field_names visible in the list in fieldsOptions-list per entity_id
        for (let entity_id in fields) {
            let entity = fields[entity_id];
            let entityfieldOptions = '<option value="0">&nbsp;</option>';
            for (let i = 0; i < entity.length; i++) {
                entityfieldOptions += `<option value=${entity[i].fieldId}>${entity[i].fieldName}</option>` + '\n';
            }
    
            fieldOptions[entity_id] = entityfieldOptions;
        }
    
        // Put the options in the document
        setfieldRefOptions();
    
    }
    
    /**
     * Update fieldS list for given entity when field name changes
     */
    function editfieldsList(field) {
    
        // Get the field_id for this field
        //const field_id = getfieldId(field);
    
        // Get the entity-id for the entity this field belongs to
        //const entity_id = getEntityIdForfield(field);
    
        // TODO: Update the fields-list and the options in the fields-dropdown for only this entity
    
        // temporary: Update ALL field-lists and options in the fields-dropdowns
        updateAllfields();
    
    }
    
    
    /**
     * Update PAGES list when something changes
     */
    function editPagesList() {
    
        pages = [].slice.call(document.querySelectorAll('.pageName'));
    
        // get the page_id of every page, creating an uuid if page_id doesn't exist
        page_ids = [];
        page_types = [];
        pages.forEach(pageName => {
            // for-var ....page_name has a hidden var ....page_id
            page_id = document.getElementById(pageName.id.replace('page_name', 'page_id'));
    
            // give that page_id an uuid if empty
            if (!page_id.value) {
                page_id.value = uuidv4();
            }
    
            page_ids.push(page_id);
    
            // and the page type
            page_types.push(document.getElementById(pageName.id.replace('page_name', 'page_type')));
        })
    
    
        // make the options with page_ids as values and page_names visible in the list
        pageOptions = '<option value="0">&nbsp;</option>';
        for (let i = 0; i < pages.length; i++) {
            pageOptions += `<option value=${page_ids[i].value}>${page_types[i].value + ': ' + pages[i].value}</option>` + '\n';
        }
    
        setPageRefOptions();
    }
    
    // TODO: following 3 functions  are almost the same -> refactor
    // put the changed ID of a referred to ENTITY (from drop down select) in the hidden field
    function backupEntityID(event) {
        // If the list was still empty: fill it...
        if (event.target.value == 999999) {
            editEntitiesList();
            return;
        }
    
        // the hidden field with the reference_id has the same id as the select box that triggered this function + _id
        reference_id = document.getElementById(event.target.id + '_id');
        reference_id.value = event.target.value;
    
        // todo: only for this entity
        updateAllfieldsOptions();
    }
    
    // put the changed ID of a referred to field (from drop down select) in the hidden field
    function backupfieldID(event) {
        // If the list was still empty: fill it...
        if (event.target.value == 999999) {
            editfieldsList();
            return;
        }
    
        // the hidden field with the field_reference_id has the same id as the select box that triggered this function + _id
        reference_id = document.getElementById(event.target.id + '_id');
        reference_id.value = event.target.value;
    }
    
    // put the changed ID of a referred to PAGE (from drop down select) in the hidden field
    function backupPageID(event) {
        // If the list was still empty: fill it...
        if (event.target.value == 999999) {
            editPagesList();
            return;
        }
    
        // the hidden field with the reference_id has the same id as the select box that triggered this function + _id
        reference_id = document.getElementById(event.target.id + '_id');
        reference_id.value = event.target.value;
    }
